<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Capabilities provide a user-friendly API to request side-effects from the shell."><meta name="keywords" content="rust, rustlang, rust-lang, capability"><title>crux_core::capability - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../crux_core/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../crux_core/index.html"><div class="logo-container"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module capability</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../index.html">crux_core</a>::<wbr><a class="mod" href="#">capability</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/crux_core/capability.rs.html#1-405">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Capabilities provide a user-friendly API to request side-effects from the shell.</p>
<p>Typically, capabilities provide I/O and host API access. Capabilities are external to the
core Crux library. Some are part of the Crux core distribution, others are expected to be built by the
community. Apps can also build single-use capabilities where necessary.</p>
<h2 id="example-use"><a href="#example-use">Example use</a></h2>
<p>A typical use of a capability would look like the following:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>update(<span class="kw-2">&amp;</span><span class="self">self</span>, event: <span class="self">Self</span>::Event, model: <span class="kw-2">&amp;mut </span><span class="self">Self</span>::Model, caps: <span class="kw-2">&amp;</span><span class="self">Self</span>::Capabilities) {
    <span class="kw">match </span>event {
        <span class="comment">//...
        </span>Event::Increment =&gt; {
            model.count += <span class="number">1</span>;
            caps.render.render(); <span class="comment">// Render capability

            </span><span class="kw">let </span>base = Url::parse(API_URL).unwrap();
            <span class="kw">let </span>url = base.join(<span class="string">&quot;/inc&quot;</span>);
            caps.http.post(url.unwrap(), Event::Set) <span class="comment">// HTTP client capability
        </span>}
    }
}</code></pre></div>
<p>Capabilities don’t <em>perform</em> side-effects themselves, they request them from the Shell. As a consequence
the capability calls within the <code>update</code> function <strong>only queue up the requests</strong>. The side-effects themselves
are performed concurrently and don’t block the update function.</p>
<p>In order to use a capability, the app needs to include it in its <code>Capabilities</code> associated type and <code>WithContext</code>
trait implementation (which can be provided by the <code>Effect</code> macro from the <code>crux_macros</code> crate). For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">mod </span>root {

<span class="comment">// An app module which can be reused in different apps
</span><span class="kw">mod </span>my_app {
    <span class="kw">use </span>crux_core::{capability::CapabilityContext, App, render::Render};
    <span class="kw">use </span>crux_macros::Effect;
    <span class="kw">use </span>serde::{Serialize, Deserialize};

    <span class="attr">#[derive(Default)]
    </span><span class="kw">pub struct </span>MyApp;
    <span class="kw">pub struct </span>Event;

    <span class="comment">// The `Effect` derive macro generates an `Effect` type that is used by the
    // Shell to dispatch side-effect requests to the right capability implementation
    // (and, in some languages, checking that all necessary capabilities are implemented)
    </span><span class="attr">#[derive(Effect)]
    #[effect(app = <span class="string">&quot;MyApp&quot;</span>)]
    </span><span class="kw">pub struct </span>Capabilities {
        <span class="kw">pub </span>render: Render&lt;Event&gt;
    }

    <span class="kw">impl </span>App <span class="kw">for </span>MyApp {
        <span class="kw">type </span>Model = ();
        <span class="kw">type </span>Event = Event;
        <span class="kw">type </span>ViewModel = ();
        <span class="kw">type </span>Capabilities = Capabilities;

        <span class="kw">fn </span>update(<span class="kw-2">&amp;</span><span class="self">self</span>, event: Event, model: <span class="kw-2">&amp;mut </span>(), caps: <span class="kw-2">&amp;</span>Capabilities) {
            caps.render.render();
        }

        <span class="kw">fn </span>view(<span class="kw-2">&amp;</span><span class="self">self</span>, model: <span class="kw-2">&amp;</span>()) {
            ()
        }
    }
}
}</code></pre></div>
<h2 id="implementing-a-capability"><a href="#implementing-a-capability">Implementing a capability</a></h2>
<p>Capabilities provide an interface to request side-effects. The interface has asynchronous semantics
with a form of callback. A typical capability call can look like this:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code>caps.ducks.get_in_a_row(<span class="number">10</span>, Event::RowOfDucks)</code></pre></div>
<p>The call above translates into “Get 10 ducks in a row and return them to me using the <code>RowOfDucks</code> event”.
The capability’s job is to translate this request into a serializable message and instruct the Shell to
do the duck herding and when it receives the ducks back, wrap them in the requested event and return it
to the app.</p>
<p>We will refer to <code>get_in_row</code> in the above call as an <em>operation</em>, the <code>10</code> is an <em>input</em>, and the
<code>Event::RowOfDucks</code> is an event constructor - a function, which eventually receives the row of ducks
and returns a variant of the <code>Event</code> enum. Conveniently, enum tuple variants can be used as functions,
and so that will be the typical use.</p>
<p>This is what the capability implementation could look like:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>crux_core::{
    capability::{CapabilityContext, Operation},
    Capability,
};
<span class="kw">use </span>serde::{Serialize, Deserialize};

<span class="comment">// A duck
</span><span class="attr">#[derive(Serialize, Deserialize, Clone, PartialEq, Eq, Debug)]
</span><span class="kw">struct </span>Duck;

<span class="comment">// Operations that can be requested from the Shell
</span><span class="attr">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
</span><span class="kw">enum </span>DuckOperation {
    GetInARow(usize)
}

<span class="comment">// Respective outputs for those operations
</span><span class="attr">#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
</span><span class="kw">enum </span>DuckOutput {
    GetInRow(Vec&lt;Duck&gt;)
}

<span class="comment">// Link the input and output type
</span><span class="kw">impl </span>Operation <span class="kw">for </span>DuckOperation {
    <span class="kw">type </span>Output = DuckOutput;
}

<span class="comment">// The capability. Context will provide the interface to the rest of the system.
</span><span class="kw">struct </span>Ducks&lt;Event&gt; {
    context: CapabilityContext&lt;DuckOperation, Event&gt;
};

<span class="kw">impl</span>&lt;Event&gt; Ducks&lt;Event&gt; {
    <span class="kw">pub fn </span>new(context: CapabilityContext&lt;DuckOperation, Event&gt;) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{ context }
    }

    <span class="kw">pub fn </span>get_in_a_row&lt;F&gt;(<span class="kw-2">&amp;</span><span class="self">self</span>, number_of_ducks: usize, event: F)
    <span class="kw">where
        </span>Event: <span class="lifetime">&#39;static</span>,
        F: Fn(Vec&lt;Duck&gt;) -&gt; Event + Send + <span class="lifetime">&#39;static</span>,
    {
        <span class="kw">let </span>ctx = <span class="self">self</span>.context.clone();
        <span class="comment">// Start a shell interaction
        </span><span class="self">self</span>.context.spawn(<span class="kw">async move </span>{
            <span class="comment">// Instruct Shell to get ducks in a row and await the ducks
            </span><span class="kw">let </span>ducks = ctx.request_from_shell(DuckOperation::GetInARow(number_of_ducks)).<span class="kw">await</span>;

            <span class="comment">// Unwrap the ducks and wrap them in the requested event
            // This will always succeed, as long as the Shell implementation is correct
            // and doesn&#39;t send the wrong output type back
            </span><span class="kw">if let </span>DuckOutput::GetInRow(ducks) = ducks {
                <span class="comment">// Queue an app update with the ducks event
                </span>ctx.update_app(event(ducks));
            }
        })
   }
}</code></pre></div>
<p>The <code>self.context.spawn</code> API allows a multi-step transaction with the Shell to be performed by a capability
without involving the app, until the exchange has completed. During the exchange, one or more events can
be emitted (allowing a subscription or streaming like capability to be built).</p>
<p>For Shell requests that have no output, you can use <a href="struct.CapabilityContext.html#method.notify_shell" title="CapabilityContext::notify_shell"><code>CapabilityContext::notify_shell</code></a>.</p>
<p><code>DuckOperation</code> and <code>DuckOutput</code> show how the set of operations can be extended. In simple capabilities,
with a single operation, these can be structs, or simpler types. For example, the HTTP capability works directly with
<code>HttpRequest</code> and <code>HttpResponse</code>.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.CapabilityContext.html" title="crux_core::capability::CapabilityContext struct">CapabilityContext</a></div><div class="item-right docblock-short">An interface for capabilities to interact with the app and the shell.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Capability.html" title="crux_core::capability::Capability trait">Capability</a></div><div class="item-right docblock-short">Implement <code>Capability</code> for your capability. This will allow
mapping events when composing apps from submodules.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Operation.html" title="crux_core::capability::Operation trait">Operation</a></div><div class="item-right docblock-short">Operation trait links together input and output of a side-effect.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.WithContext.html" title="crux_core::capability::WithContext trait">WithContext</a></div><div class="item-right docblock-short">Allows Crux to construct app’s set of required capabilities, providing context
they can then use to request effects and dispatch events.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="crux_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>